{
  "hash": "97cceb9ffbbfaf3f1f4737278ed9996b",
  "result": {
    "markdown": "---\ntitle: How to fill maps with density gradients with R, {ggplot2}, and {sf}\ndate: 2023-07-28\ndescription: \"Fix overplotted points on maps by creating bins or filled desntiy gradients using R, {ggplot2}, and {sf}\"\nimage: index_files/figure-html/plot-all-1.png\ntwitter-card:\n  image: \"index_files/figure-html/plot-all-1.png\"\nopen-graph:\n  image: \"index_files/figure-html/plot-all-1.png\"\ncategories:\n  - r\n  - tidyverse\n  - ggplot\n  - gis\n  - maps\ndoi: 10.59350/bsctw-0a955\ncitation: true\n---\n\n\n\n\nThe students in my [summer data visualization class](https://datavizs23.classes.andrewheiss.com/) are finishing up their [final projects](https://datavizs23.classes.andrewheiss.com/assignment/final-project.html) this week and I've been answering a bunch of questions on our class Slack. Often these are relatively standard reminders of how to tinker with specific ggplot layers (chaning the colors of a legend, adding line breaks in labels, etc.), but today one student had a fascinating and tricky question that led me down a realy fun dataviz rabbit hole. She was making a map with hundreds of points representing specific locations of events. This led to [overplotting](https://r-graphics.org/recipe-scatter-overplot)—it's really hard to stick hundreds of dots on a small map of a city and have it make any sense. To help fix this, she wanted to fill areas of the map by the count of events, making a filled gradient rather than a bunch of points. This is fairly straightforward with regular scatterplots, but working with geographic data adds some extra wrinkles to the process.\n\nSo let's all go down this rabbit hole together (mostly so future-me can remember how to do this)!\n\n::: {.callout-note}\n### Who this post is for\n\nHere's what I assume you know:\n\n- You're familiar with [R](https://www.r-project.org/) and the [tidyverse](https://www.tidyverse.org/) (particularly [{dplyr}](https://dplyr.tidyverse.org/) and [{ggplot2}](https://ggplot2.tidyverse.org/)).\n- You're somewhat familiar with [{sf}](https://r-spatial.github.io/sf/) for working with geographic data. I have a [whole tutorial here](https://datavizs23.classes.andrewheiss.com/example/12-example.html) and a [simplified one here](https://www.andrewheiss.com/blog/2023/04/26/middle-earth-mapping-sf-r-gis/#lightning-quick-overview-of-sf-and-shapefiles) and the [{sf} documentation has a ton of helpful vignettes and blog posts](https://r-spatial.github.io/sf/), and there are also two free books about it: [*Spatial Data Science*](https://r-spatial.org/book/) and [*Geocomputation with R*](https://r.geocompx.org/). Also [check this fantastic post out](https://www.jessesadler.com/post/simple-feature-objects/) to learn more about the anatomy of a `geometry` column with {sf}.\n\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(spatstat)\nlibrary(tigris)\nlibrary(rnaturalearth)\nlibrary(patchwork)\n\ntheme_set(\n  theme_void(base_family = \"Roboto Slab\") +\n    theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n)\n```\n:::\n\n\n\n# Fixing overplotted scatterplots\n\nOverplotting happens when there are too many data points in one place in a plot. For instance, here's a scatterplot of carats and prices for 54,000 diamonds, using {ggplot2}'s built-in `diamonds` dataset:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-xy-overplot-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nWoof. It's just a blob of black points. \n\nTo fix overplotting, you can either restyle the points somehow so they're not so crowded, or you can summarize the data and display it a slightly different way. There are lots of possible ways to fix this though—here's a quick overview of some:\n\n::: {.panel-tabset .nav-pills}\n### Smaller points\n\nWe can try shrinking the points down a bunch:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point(size = 0.2) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-xy-size-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n### Semi-transparent points\n\nWe can make the points partially transparent so that clusters of points are darker (with more points stacked on top of each other)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point(alpha = 0.01) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-xy-alpha-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n### ■-binned points\n\nWe can draw a grid across the x- and y-axes and count how many points fall inside each box, then fill each box by that count. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat, y = price)) +\n  stat_bin2d() +\n  scale_fill_viridis_c() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-xy-bin-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n### ⬢-binned points\n\nWe can draw a hexagonal grid across the x- and y-axes and count how many points fall inside each hexagon, then fill each hexagon by that count. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(diamonds, aes(x = carat, y = price)) +\n  stat_binhex() +\n  scale_fill_viridis_c() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-xy-hexbin-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n### Density countours\n\nWe can also find the combined density of points along both the x- and y-axes and plot the contours of those densities. Here, the brighter the area, the more concentrated the points:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwithr::with_seed(4393, {\n  dsmall <- diamonds[sample(nrow(diamonds), 1000), ]\n})\n\nggplot(dsmall, aes(x = carat, y = price)) +\n  geom_density2d_filled() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-xy-density-contour-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n:::\n\n# Initial overplotted map\n\nGeographic data, however, is a little trickier to work with. Fundamentally, putting points on a map is the same as making a scatterplot, with latitude on the x-axis and longitude on the y-axis. But maps are strange. Scatterplots are nice rectangles; maps have oddly shaped borders. Scatterplots are naturally flat; maps are curved chunks of a globe and [have to be flattened](https://www.youtube.com/watch?v=kIID5FDi2JQ) and [reprojected](https://observablehq.com/@d3/projection-comparison) into two dimensions somehow. Scatterplots come from nice rectangular datasets; maps from from complex shapefiles.\n\nShrinking and transparentifying points with map points is the same as with regular points: play with the `size` and `alpha` arguments in `geom_sf()`. Making bins and gradients, however, takes a little more work (hence this rabbit hole).\n\nTo illustrate this, we'll plot all 264 campgrounds in the state of Georgia. This doesn't involve *severe* overplotting (though at the end [I've included an example of dealing with 10,000 map points](#extra-bonus-fun-10000-churches)), but it's useful for playing with these different techniques.\n\nThe data comes from [Georgia's GIS Clearinghouse](https://data.georgiaspatial.org/), which is a miserable ancient website that requires a (free) login. I downloaded the GNIS Cultural Features dataset (last updated in 1996; [direct link](https://data.georgiaspatial.org/index.asp?body=preview&dataId=11422) + [documentation](https://data.georgiaspatial.org/data/statewide/gnis/gnis.html)). Since it's government data from the US Department of the Interior and ostensibly public domain, you can download the shapefile here:\n\n- [{{< fa file-archive >}}`cultural.zip`](data/cultural.zip)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# We'll make all the shapefiles use ESRI:102118 (NAD 1927 Georgia Statewide\n# Albers: https://epsg.io/102118)\nga_crs <- st_crs(\"ESRI:102118\")\n\n# Geographic data from Georgia\nga_cultural <- read_sf(\"data/cultural/cultural.shp\") %>% \n  # This shapefile uses EPSG:4326 (WGS 84), but that projection information\n  # isn't included in the shapefile for whatever reason, so we need to set it\n  st_set_crs(st_crs(\"EPSG:4326\"))\n\nga_campgrounds <- ga_cultural %>% \n  filter(DESCRIPTOR == \"CAMP/CAMPGROUND\") %>% \n  st_transform(ga_crs)\n```\n:::\n\n\nWe'll also grab a state map of Georgia and a map of all Georgia counties from the US Census Bureau using [the {tigris} package](https://github.com/walkerke/tigris):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Geographic data from the US Census\noptions(tigris_use_cache = TRUE)\nSys.setenv(TIGRIS_CACHE_DIR = \"maps\")\n\nga_state <- states(cb = TRUE, resolution = \"500k\", year = 2022) %>% \n  filter(STUSPS == \"GA\") %>% \n  st_transform(ga_crs)\n\nga_counties <- counties(state = \"13\", cb = TRUE, resolution = \"500k\", year = 2022) %>% \n  st_transform(ga_crs)\n```\n:::\n\n\nAnd finally, to help illustrate maps aren't mere scatterplots, we'll add all of Georgia's rivers and lakes to the maps we make. Lots of campgrounds are clustered around lakes, so this will also help us see some patterns in the data. We'll get river and lake data from the Natural Earth project, which provides all sorts of [physical map data](https://www.naturalearthdata.com/downloads/10m-physical-vectors/) like coastlines, reefs, islands, and so on. They provide shapefiles for large rivers and lakes globally (`rivers_lake_centerlines` and `lakes`) and smaller rivers and lakes in North America specifically (`rivers_north_america` and `lakes_north_america`).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# See rnaturalearth::df_layers_physical for all possible names\n# Create a vector of the four datasets we want\nne_shapes_to_get <- c(\n  \"rivers_lake_centerlines\", \"rivers_north_america\",\n  \"lakes\", \"lakes_north_america\"\n)\n\n# Loop through ne_shapes_to_get and download each shapefile and store it locally\nif (!file.exists(\"maps/ne_10m_lakes.shp\")) {\n  ne_shapes_to_get %>%\n    walk(~ ne_download(\n      scale = 10, type = .x, category = \"physical\",\n      destdir = \"maps\", load = FALSE\n    ))\n}\n\n# Load each pre-downloaded shapefile and store it in a list\nne_data_list <- ne_shapes_to_get %>%\n  map(~ {\n    ne_load(\n      scale = 10, type = .x, category = \"physical\",\n      destdir = \"maps\", returnclass = \"sf\"\n    ) %>%\n      st_transform(ga_crs)\n  }) %>%\n  set_names(ne_shapes_to_get)\n\n# Load all the datasets in the list into the global environment\nlist2env(ne_data_list, envir = .GlobalEnv)\n## <environment: R_GlobalEnv>\n```\n:::\n\n\nThese physical shapefiles from Natural Earth contain thousands of rivers and lakes, but we only want the ones that exist in or cross through Georgia. We can use the Georgia state shapefile we got from the Census (`ga_state`) as a sort of cookie cutter on each of these larger shapefiles to only keep the parts of rivers and lakes that fall within Georgia's boundaries:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ↓ these give a bunch of (harmless?) warnings about spatially constant attributes\nrivers_global_ga <- st_intersection(ga_state, rivers_lake_centerlines)\nrivers_na_ga <- st_intersection(ga_state, rivers_north_america)\nlakes_global_ga <- st_intersection(ga_state, lakes)\nlakes_na_ga <- st_intersection(ga_state, lakes_north_america)\n```\n:::\n\n\nHere's what our initial map looks like, with fancy rivers and maps added. It looks nice and detailed, but there are a lot of points, and even shrinking them down to 0.5, there are a few overplotted clusters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_initial <- ggplot() +\n  geom_sf(data = ga_state, fill = \"grey20\") +\n  geom_sf(data = rivers_global_ga, linewidth = 0.3, color = \"white\") +\n  geom_sf(data = rivers_na_ga, linewidth = 0.1, color = \"white\") +\n  geom_sf(data = lakes_global_ga, fill = \"white\", color = NA) +\n  geom_sf(data = lakes_na_ga, fill = \"white\", color = NA) +\n  geom_sf(data = ga_campgrounds, size = 0.5, color = \"grey50\") +\n  # Technically this isn't necessary since all the layers already use 102118, but\n  # we'll add it just in case I forgot to do that to one of them\n  coord_sf(crs = ga_crs)\nplot_initial\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-initial-map-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n# Option 1: Fill each county by the number of campgrounds\n\nOne way to address this overplotting is to create bins with counts of the campgrounds in each bin. US states have a natural kind of \"bin\", since they're subdivided into counties. Georgia has [an inordinate number of counties](https://www.wabe.org/why-ga-has-second-highest-number-counties-us/), so we can count the number of campgrounds per county and fill each county by that count. We'll join the campground data to the county data with `st_join()` (which is the geographic equivalent of `left_join()`) and then use some `group_by() %>% summarize()` magic to find the number of locations per county.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# st_join() adds extra rows for repeated counties and returns partially blank\n# rows for counties with no campgrounds. It would ordinarily be easy to use\n# `summarize(total = n())`, but this won't be entirely accurate since counties\n# without campgrounds still appear in the combined data and would get\n# incorrectly counted. So instead, we look at one of the columns from\n# ga_campgrounds (DESCRIPTOR). If it's NA, it means that the county it was\n# joined to didn't have any campgrounds, so we can ignore it when counting.\nga_counties_campgrounds <- ga_counties %>% \n  st_join(ga_campgrounds) %>% \n  group_by(NAMELSAD) %>% \n  summarize(total = sum(!is.na(DESCRIPTOR)))\n```\n:::\n\n\nWe can plot this new `ga_counties_campgrounds` data and fill by `total`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_county <- ggplot() +\n  geom_sf(data = ga_counties_campgrounds, aes(fill = total), color = NA) +\n  geom_sf(data = ga_state, fill = NA, color = \"black\", linewidth = 0.25) +\n  geom_sf(data = rivers_global_ga, linewidth = 0.3, color = \"white\") +\n  geom_sf(data = rivers_na_ga, linewidth = 0.1, color = \"white\") +\n  geom_sf(data = lakes_global_ga, fill = \"white\", color = NA) +\n  geom_sf(data = lakes_na_ga, fill = \"white\", color = NA) +\n  scale_fill_viridis_c(option = \"magma\", guide = \"none\", na.value = \"black\") +\n  coord_sf(crs = ga_crs)\nplot_county\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-county-fills-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nThis already helps. We can see a cluster of campgrounds in central Georgia around the Piedmont National Wildlife Refuge and the Oconee National Forest, and another cluster in the mountains of northeast Georgia in the Chattahoochee-Oconee National forests.\n\n\n# Option 2: Create a grid and fill each grid box by the number of campgrounds\n\nCounties are oddly shaped, though, and not all states or cities have this many subdivisions to work with. So instead, we can create our own subdivisions. We can use `st_make_grid()` to divide the state area up into a grid—here we'll use 400 boxes:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Spit the state area into a 20x20 grid\nga_grid <- ga_state %>% \n  st_make_grid(n = c(20, 20))\n\nggplot() +\n  geom_sf(data = ga_state) +\n  geom_sf(data = ga_grid, alpha = 0.3) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/create-grid-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nWe can then use `st_intersection()` to cut the Georgia map into pieces that fall in each of those grid boxes:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nga_grid_map <- st_intersection(ga_state, ga_grid) %>% \n  st_as_sf() %>% \n  mutate(grid_id = 1:n())\n\nggplot() +\n  geom_sf(data = ga_grid_map) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/cut-map-grid-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nNext we can join the campground data to these boxes just like we did with the counties, and we can use `group_by() %>% summarize()` to get counts in each grid box:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncampgrounds_per_grid_box <- ga_grid_map %>% \n  st_join(ga_campgrounds) %>% \n  group_by(grid_id) %>% \n  summarize(total = sum(!is.na(DESCRIPTOR)))\n```\n:::\n\n\nFinally we can plot it:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_grid <- ggplot() +\n  geom_sf(data = campgrounds_per_grid_box, aes(fill = total), color = NA) +\n  geom_sf(data = ga_state, fill = NA, color = \"black\", linewidth = 0.25) +\n  geom_sf(data = rivers_global_ga, linewidth = 0.3, color = \"white\") +\n  geom_sf(data = rivers_na_ga, linewidth = 0.1, color = \"white\") +\n  geom_sf(data = lakes_global_ga, fill = \"white\", color = NA) +\n  geom_sf(data = lakes_na_ga, fill = \"white\", color = NA) +\n  scale_fill_viridis_c(option = \"magma\", guide = \"none\") +\n  coord_sf(crs = ga_crs)\nplot_grid\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-grid-fills-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nThat feels more uniform than the counties and still highlights the clusters of campgrounds in central and northeast Georgia.\n\n\n# Option 3: Fill with a gradient of the density of the number of campgrounds\n\nHowever, it is a little misleading. Technically there are more campgrounds in northeast Georgia than in central Georgia, but because of how (1) county boundaries happened to be drawn, and (2) how the gridlines happened to be drawn, the campgrounds in the northeast were spread across multiple counties/tiles while the campgrounds in central Georgia happened to mostly fall in one county/tile, so it looks like there are more down there.\n\nTo make the shading more accurate, we can turn to turn to calculus and imagine grid boxes that are infinitely small. We can calculate densities instead of binned or clustered subunits.\n\nDoing this with geographic data is tricky, though, and requires some extra math and an extra package to handle the fancy math: [{spatstat}](https://spatstat.org/). (See [this](https://rspatial.org/rosu/Chapter5.html) and [this](https://mgimond.github.io/Spatial/point-pattern-analysis-in-r.html) and [this](https://maczokni.github.io/crime_mapping_textbook/studying-spatial-point-patterns.html) and [this](https://stackoverflow.com/a/68647062/120898) for some examples of using {spatstat}.)\n\nTo calculate the density of campground latitudes and longitudes, we need to first convert our geometry column to a spatial point pattern object (or a `ppp` object) that {spatstat} can work with. Like `sf` objects, a `ppp` object is a collection of geographic points, and it can have overall boundaries embedded in it, or what {spatstat} calls a \"window\":\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Convert the campground coordinates to a ppp object with a built-in window\nga_campgrounds_ppp <- as.ppp(ga_campgrounds$geometry, W = as.owin(ga_state))\n\n# Check to see if it worked\nplot(ga_campgrounds_ppp)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/make-campground-ppp-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n`ppp` objects have a corresponding `density()` function that can calculate the joint densities of each point's latitude and longitude coordinates. It also has a `dimyx` argument that controls the number of pixels of the density—higher numbers will create smoother and higher resolution images; smaller numbers will be chunkier and less granular. The resulting object is a pixel-based bitmap image with extra attributes that describe how to connect it back to latitude and longitude points. If we feed that image to `stars::st_as_stars()` (from [the {stars} package](https://r-spatial.github.io/stars/)), we'll force the image to use that geographic data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create a stars object of the density of campground locations\ndensity_campgrounds_stars <- stars::st_as_stars(density(ga_campgrounds_ppp, dimyx = 300))\n\n# Check to see what it looks like\nplot(density_campgrounds_stars)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/make-campground-density-stars-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\n::: {.callout-important}\n### {spatstat} and projections\n\nIMPORTANTLY `density.ppp()` doesn't work with all CRS systems. From my experimenting, it seems to only work with projections that use meters as their units, like Albers and NAD 83. It gave me an error anytime I tried working with decimal degrees (i.e. the −180° to 180° scale). I don't know why :(. That's why I've forced all the different geographic datasets in this post to use [ESRI:102118](https://epsg.io/102118) (Georgia Statewide Albers)—it uses meters and it works.\n:::\n\nWe can convert this {stars} object back to {sf} so it's normal and plottable with `geom_sf()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nga_campgrounds_density <- st_as_sf(density_campgrounds_stars) %>%\n  st_set_crs(ga_crs)\n```\n:::\n\n\nWe can then plot it with `ggplot()` and `geom_sf()` like normal, filling by `v`, which is the column that stores the calculated density:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_density <- ggplot() +\n  geom_sf(data = ga_campgrounds_density, aes(fill = v), color = NA) +\n  geom_sf(data = ga_state, fill = NA, color = \"black\", linewidth = 0.25) +\n  scale_fill_viridis_c(option = \"magma\", guide = \"none\")\nplot_density\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-density-simple-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nooooh that's so pretty already. Let's add all the rivers and lakes:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_density_fancy <- ggplot() +\n  geom_sf(data = ga_campgrounds_density, aes(fill = v), color = NA) +\n  geom_sf(data = ga_state, fill = NA, color = \"black\", linewidth = 0.25) +\n  geom_sf(data = rivers_global_ga, linewidth = 0.3, color = \"white\") +\n  geom_sf(data = rivers_na_ga, linewidth = 0.1, color = \"white\") +\n  geom_sf(data = lakes_global_ga, fill = \"white\", color = NA) +\n  geom_sf(data = lakes_na_ga, fill = \"white\", color = NA) +\n  scale_fill_viridis_c(option = \"magma\", guide = \"none\") +\n  coord_sf(crs = ga_crs)\nplot_density_fancy\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-density-fancy-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nAbsolutely stunning.\n\nWe can add the actual campground points back in too:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_density_fancy_points <- ggplot() +\n  geom_sf(data = ga_campgrounds_density, aes(fill = v), color = NA) +\n  geom_sf(data = ga_state, fill = NA, color = \"black\", linewidth = 0.25) +\n  geom_sf(data = rivers_global_ga, linewidth = 0.3, color = \"white\") +\n  geom_sf(data = rivers_na_ga, linewidth = 0.1, color = \"white\") +\n  geom_sf(data = lakes_global_ga, fill = \"white\", color = NA) +\n  geom_sf(data = lakes_na_ga, fill = \"white\", color = NA) +\n  geom_sf(data = ga_campgrounds, size = 0.3, color = \"grey80\") +\n  scale_fill_viridis_c(option = \"magma\", guide = \"none\") +\n  coord_sf(crs = ga_crs)\nplot_density_fancy_points\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-density-fancy-points-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nThat's so so cool.\n\n# Comparison\n\nHere's what all these options look like together. There's no one single best option—it depends on what story you're trying to tell, how the data is distributed, how crowded it is, and so on—but it's cool that there are so many options!\n\n\n::: {.cell .column-body-outset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nlayout <- \"\n#####\n#A#BC\n#####\n#D#EF\n#####\nG####\n\"\n\n(plot_initial + labs(title = \"Overplotted\") + theme(plot.background = element_rect(fill = \"white\", color = NA))) +\n  (plot_county + labs(title = \"Filled by county\") + theme(plot.background = element_rect(fill = \"white\", color = NA))) +\n  plot_spacer() +\n  (plot_grid + labs(title = \"Filled by grid\") + theme(plot.background = element_rect(fill = \"white\", color = NA))) + \n  (plot_density_fancy + labs(title = \"Filled by density\") + theme(plot.background = element_rect(fill = \"white\", color = NA))) +\n  plot_spacer() + plot_spacer() +\n  plot_layout(design = layout, widths = c(0.02, 0.47, 0.02, 0.47, 0.02), heights = c(0.02, 0.47, 0.02, 0.47, 0.02)) +\n  plot_annotation(theme = theme(plot.background = element_rect(fill = \"grey95\", color = NA)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-all-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n# Extra bonus fun: 10,000+ churches\n\nFinally, for some extra fun, let's plot something that's *actually* overplotted—Georgia's 10,000+ churches!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nga_churches <- ga_cultural %>% \n  filter(DESCRIPTOR == \"CHURCH\") %>% \n  st_transform(st_crs(\"ESRI:102118\"))\n\nggplot() +\n  geom_sf(data = ga_state) +\n  geom_sf(data = ga_churches)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-churches-initial-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nlol this is basically just a wildly overplotted [population map](https://xkcd.com/1138/) at this point. Let's calculate the density of these locations and plot a gradient:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Convert the church coordinates to a ppp object with a built-in window\nga_churches_ppp <- as.ppp(ga_churches$geometry, W = as.owin(ga_state))\n\n# Create a stars object (whatever that is) of the density of church locations\ndensity_churches_stars <- stars::st_as_stars(density(ga_churches_ppp, dimyx = 300))\n\n# Convert the stars object to an sf object so it's normal and plottable again\nga_churches_density <- st_as_sf(density_churches_stars) %>%\n  st_set_crs(ga_crs)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = ga_churches_density, aes(fill = v), color = NA) +\n  geom_sf(data = ga_state, fill = NA, color = \"black\", linewidth = 0.25) +\n  geom_sf(data = ga_churches, size = 0.005, alpha = 0.3) +\n  scale_fill_viridis_c(option = \"rocket\", guide = \"none\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-church-density-1.png){fig-align='center' width=70%}\n:::\n:::\n\n\nCheck out that hugely bright spot in Atlanta!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}