{
  "hash": "3175f82b0498aca904d96f0ae4ce3d71",
  "result": {
    "markdown": "---\ntitle: Show multiply imputed results in a side-by-side regression table with broom and huxtable\ndate: 2018-03-08\ndescription: Extend broom's tidy() and glance() to work with lists of multiply imputed regression models\ncategories: \n  - r\n  - imputation\n  - tidyverse\n  - markdown\n---\n\n\n\n\n<span class=\"small\">([See this notebook on GitHub](https://github.com/andrewheiss/amelia-broom-huxtable))</span>\n\n---\n\n*tl;dr*: Use the functions in [`broomify-amelia.R`](broomify-amelia.R) to use `broom::tidy()`, `broom::glance()`, and `huxtable::huxreg()` on lists of multiply imputed models.\n\n---\n\nThe whole reason I went into the rabbit hole of the mechanics of merging imputed regression results [in the previous post](https://www.andrewheiss.com/blog/2018/03/07/amelia-tidy-melding/) was so I could easily report these results in papers and writeups. In political science and economics (and probably other social science disciplines), it's fairly standard to report many regression models in a side-by-side table, with a column for each model and rows for each coefficient. R packages like [`stargazer`](https://cran.r-project.org/package=stargazer) and [`huxtable`](https://cran.r-project.org/package=huxtable) make this fairly straightforward.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(Amelia)\nlibrary(stargazer)\nlibrary(huxtable)\nlibrary(broom)\n\n# Use the africa dataset from Ameila\ndata(africa)\n\n# Build some example models\nmodel_original1 <- lm(gdp_pc ~ trade + civlib, data = africa)\nmodel_original2 <- lm(gdp_pc ~ trade + civlib + infl, data = africa)\n```\n:::\n\n\nStargazer takes a list of models:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstargazer(model_original1, model_original2, type = \"text\")\n## \n## ====================================================================\n##                                   Dependent variable:               \n##                     ------------------------------------------------\n##                                          gdp_pc                     \n##                               (1)                      (2)          \n## --------------------------------------------------------------------\n## trade                      18.000***                18.500***       \n##                             (1.270)                  (1.200)        \n##                                                                     \n## civlib                    -665.000***              -589.000***      \n##                            (185.000)                (176.000)       \n##                                                                     \n## infl                                                -6.340***       \n##                                                      (1.620)        \n##                                                                     \n## Constant                    136.000                 166.000*        \n##                            (100.000)                (94.900)        \n##                                                                     \n## --------------------------------------------------------------------\n## Observations                  115                      115          \n## R2                           0.653                    0.695         \n## Adjusted R2                  0.647                    0.687         \n## Residual Std. Error    352.000 (df = 112)      332.000 (df = 111)   \n## F Statistic         106.000*** (df = 2; 112) 84.500*** (df = 3; 111)\n## ====================================================================\n## Note:                                    *p<0.1; **p<0.05; ***p<0.01\n```\n:::\n\n\nAs does huxtable's `huxreg()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhuxreg(model_original1, model_original2) %>%\n  print_screen()\n##                    ────────────────────────────────────────────────────\n##                                            (1)              (2)        \n##                                     ───────────────────────────────────\n##                      (Intercept)         136.063          166.435      \n##                                         (100.409)         (94.871)     \n##                      trade                18.027 ***       18.494 ***  \n##                                           (1.272)          (1.204)     \n##                      civlib             -665.428 ***     -588.722 **   \n##                                         (185.436)        (175.717)     \n##                      infl                                  -6.336 ***  \n##                                                            (1.620)     \n##                                     ───────────────────────────────────\n##                      N                   115              115          \n##                      R2                    0.653            0.695      \n##                      logLik             -836.136         -828.709      \n##                      AIC                1680.272         1667.418      \n##                    ────────────────────────────────────────────────────\n##                      *** p < 0.001; ** p < 0.01; * p < 0.05.           \n## \n## Column names: names, model1, model2\n```\n:::\n\n\n[Stargazer has support for a ton of different model types](https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf) (see `?stargazer` for details), but they're all hardcoded into stargazer's internal code and adding more is tricky. [Huxtable](https://hughjonesd.github.io/huxtable/), on the other hand, doesn't rely on hardcoded model processing, but instead will display any model that works with `broom::tidy()` and `broom::glance()`. The [`broom` package](https://cran.r-project.org/package=broom) supports way more models than stargazer (including models created with [`rstan`](https://cran.r-project.org/package=rstan) and [`rstanarm`](https://cran.r-project.org/package=rstanarm)!), and because of this, huxtable is far more extensible—if you can create a `tidy()` and a `glance()` function for a type of model, huxtable can use it. \n\nAlso, stargazer was written before [R Markdown](https://rmarkdown.rstudio.com/) was really a thing, so it has excellent support for HTML and LaTeX output, but that's it. Including stargazer tables in an R Markdown document is a hassle, especially if you want to be able to convert it to Word ([I've written a Python script for doing this](https://github.com/andrewheiss/edb-social-pressure/blob/master/bin/stargazer2docx.py)—that's how much extra work it takes). Huxtable, though, was written after the R Markdown and tidyverse revolutions, so it supports piping *and* can output to HTML, LaTeX, *and* Markdown (with `huxtable::print_md()`). \n\nThis history is important because it means that models based on multiple imputation **will not work with stargazer.** Melding all the coefficients across imputations creates nice data frames of model results, but it doesn't create a model that stargazer can work with. This is unfortunate, especially given [how much I use stargazer](https://github.com/search?l=&q=stargazer+user%3Aandrewheiss&ref=advsearch&type=Code&utf8=%E2%9C%93). However, if we could make a `tidy()` and a `glance()` function that could work with a list of multiply imputed models, huxtable would solve all our problems.\n\nSo here's how to solve all your problems :)\n\nFirst, we'll impute the missing data in the Africa data set, nest the imputed data in a larger data frame, and run a model on each imputed dataset:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1234)\nimp_amelia <- amelia(x = africa, m = 5, cs = \"country\", ts = \"year\", \n                     logs = \"gdp_pc\", p2s = 0)\n\nmodels_imputed_df <- bind_rows(unclass(imp_amelia$imputations), .id = \"m\") %>%\n  group_by(m) %>%\n  nest() %>% \n  mutate(model = data %>% map(~ lm(gdp_pc ~ trade + civlib, data = .)))\n\nmodels_imputed_df\n## # A tibble: 5 × 3\n## # Groups:   m [5]\n##   m     data               model \n##   <chr> <list>             <list>\n## 1 imp1  <tibble [120 × 7]> <lm>  \n## 2 imp2  <tibble [120 × 7]> <lm>  \n## 3 imp3  <tibble [120 × 7]> <lm>  \n## 4 imp4  <tibble [120 × 7]> <lm>  \n## 5 imp5  <tibble [120 × 7]> <lm>\n```\n:::\n\n\nBefore we do anything with the models in `models_imputed_df$model`, first we can define a few functions to extend broom. R's S3 object system means that a function named `whatever.blah()` will automatically work when called on objects with the class `blah`. This is how broom generally works—there are functions named `tidy.anova()`, `tidy.glm()`, `tidy.lm()`, etc. that will do the correct tidying when run on `anova`, `glm`, and `lm` objects. Huxtable also takes advantage of this S3 object system—it will call the appropriate tidy and glance functions based on the class of the models passed to it.\n\nTo make a list of models work with broom, we need to invent a new class of model. In this example I've named it `melded`, but it could be anything. Here are three functions designed to work on `melded` objects (the code for these is largely based on [the previous post about melding coefficients](https://www.andrewheiss.com/blog/2018/03/07/amelia-tidy-melding/)). These functions are also found in [`broomify-amelia.R`](broomify-amelia.R), which you can add to your project (maybe someday this could be an actual package, but I don't see a reason for it yet).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntidy.melded <- function(x, conf.int = FALSE, conf.level = 0.95) {\n  # Get the df from one of the models\n  model_degrees_freedom <- glance(x[[1]])$df.residual\n  \n  # Create matrices of the estimates and standard errors\n  params <- tibble(models = unclass(x)) %>%\n    mutate(m = 1:n(),\n           tidied = models %>% map(tidy)) %>% \n    unnest(tidied) %>%\n    select(m, term, estimate, std.error) %>%\n    gather(key, value, estimate, std.error) %>%\n    mutate(term = fct_inorder(term)) %>%  # Order the terms so that spread() keeps them in order\n    spread(term, value)\n  \n  just_coefs <- params %>% filter(key == \"estimate\") %>% select(-m, -key)\n  just_ses <- params %>% filter(key == \"std.error\") %>% select(-m, -key)\n  \n  # Meld the coefficients with Rubin's rules\n  coefs_melded <- mi.meld(just_coefs, just_ses)\n  \n  # Create tidy output\n  output <- as.data.frame(cbind(t(coefs_melded$q.mi),\n                                t(coefs_melded$se.mi))) %>%\n    magrittr::set_colnames(c(\"estimate\", \"std.error\")) %>%\n    mutate(term = rownames(.)) %>%\n    select(term, everything()) %>%\n    mutate(statistic = estimate / std.error,\n           p.value = 2 * pt(abs(statistic), model_degrees_freedom, lower.tail = FALSE))\n  \n  # Add confidence intervals if needed\n  if (conf.int & conf.level) {\n    # Convert conf.level to tail values (0.025 when it's 0.95)\n    a <- (1 - conf.level) / 2\n    \n    output <- output %>% \n      mutate(conf.low = estimate + std.error * qt(a, model_degrees_freedom),\n             conf.high = estimate + std.error * qt((1 - a), model_degrees_freedom))\n  }\n  \n  # tidy objects only have a data.frame class, not tbl_df or anything else\n  class(output) <- \"data.frame\"\n  output\n}\n\nglance.melded <- function(x) {\n  # Because the properly melded parameters and the simple average of the\n  # parameters of these models are roughly the same (see\n  # https://www.andrewheiss.com/blog/2018/03/07/amelia-tidy-melding/), for the\n  # sake of simplicty we just take the average here\n  output <- tibble(models = unclass(x)) %>%\n    mutate(glance = models %>% map(glance)) %>%\n    unnest(glance) %>%\n    summarize_at(vars(r.squared, adj.r.squared, sigma, statistic, p.value, df, \n                      logLik, AIC, BIC, deviance, df.residual),\n                 list(mean)) %>%\n    mutate(m = as.integer(length(x)))\n  \n  # glance objects only have a data.frame class, not tbl_df or anything else\n  class(output) <- \"data.frame\"\n  output\n}\n\nnobs.melded <- function(x, ...) {\n  # Take the number of observations from the first model\n  nobs(x[[1]])\n}\n```\n:::\n\n\nWith these three functions, we can now use `glance()` and `tidy()` on a list of models with the class `melded`, like so:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Extract the models into a vector and make it a \"melded\" class\nmodels_imputed <- models_imputed_df$model\n# Without this, R won't use our custom tidy.melded() or glance.melded() functions\nclass(models_imputed) <- \"melded\"\nglance(models_imputed)\n##   r.squared adj.r.squared sigma statistic  p.value df logLik  AIC  BIC deviance\n## 1     0.657         0.651   348       112 9.68e-28  2   -871 1750 1761 14154815\n##   df.residual m\n## 1         117 5\ntidy(models_imputed)\n##                    term estimate std.error statistic  p.value\n## (Intercept) (Intercept)    120.6     96.67      1.25 2.15e-01\n## trade             trade     18.1      1.24     14.63 3.45e-28\n## civlib           civlib   -637.8    181.13     -3.52 6.13e-04\n```\n:::\n\n\nEven better, though, is that we can use these imputed models in a huxtable regression table. And, because I included a column named `m` in `glance.melded()`, we can also include it in the regression output!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhuxreg(model_original1, model_original2, models_imputed,\n       statistics = c(N = \"nobs\", R2 = \"r.squared\", `Adj R2` = \"adj.r.squared\", \n                      \"logLik\", \"AIC\", \"m\")) %>% \n  print_screen()\n##                ────────────────────────────────────────────────────────────\n##                                    (1)            (2)            (3)       \n##                              ──────────────────────────────────────────────\n##                  (Intercept)    136.063        166.435        120.591      \n##                                (100.409)       (94.871)       (96.669)     \n##                  trade           18.027 ***     18.494 ***     18.089 ***  \n##                                  (1.272)        (1.204)        (1.237)     \n##                  civlib        -665.428 ***   -588.722 **    -637.832 ***  \n##                                (185.436)      (175.717)      (181.130)     \n##                  infl                           -6.336 ***                 \n##                                                 (1.620)                    \n##                              ──────────────────────────────────────────────\n##                  N              115            115            120          \n##                  R2               0.653          0.695          0.657      \n##                  Adj R2           0.647          0.687          0.651      \n##                  logLik        -836.136       -828.709       -870.954      \n##                  AIC           1680.272       1667.418       1749.908      \n##                  m                                              5.000      \n##                ────────────────────────────────────────────────────────────\n##                  *** p < 0.001; ** p < 0.01; * p < 0.05.                   \n## \n## Column names: names, model1, model2, model3\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}